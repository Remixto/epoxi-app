package io.epoxi.repository.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import io.epoxi.repository.modelbase.EngineMember;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.List;


/**
 * a list of field names that define the schema. This may be a subset of all fields available within
 * the stream. The schema fields are considered to be all fields array of fields is not populated.
 **/
@Entity
@ApiModel(description = "a list of field names that define the schema.  This may be a subset of all fields available within the stream. The schema fields are considered to be all fields array of fields is not populated.")
public class Schema {

    private Schema()
    {}

    @ApiModelProperty(value = "the internal Id of the schema.  This is autogenerated.")
    @Getter(onMethod=@__({@JsonProperty("id")}))
    @Id private final Long id = null;

    @ApiModelProperty(value = "a list of field names that define the specific fields from the stream to be ingested.  If not present, all fields within the stream will be ingested")
    @NotNull
    @Getter(onMethod=@__({@JsonProperty("fields")}))
    @Setter
    private List<Field> fields = new ArrayList<>();

    @ApiModelProperty(required = true, value = "a list of fields that comprise a unique key for the schema")
    @NotNull
    @Getter(onMethod=@__({@JsonProperty("keyFields")}))
    @Setter
    private List<String> keyFields = new ArrayList<>();


    public Schema addFieldsItem(Field fieldsItem) {
        this.fields.add(fieldsItem);
        return this;
    }

    public Schema addKeyFieldsItem(String keyFieldsItem) {
        this.keyFields.add(keyFieldsItem);
        return this;
    }

    @Override
    public String toString() {
        return EngineMember.toString(this);
    }


    public List<String> getFieldNames()
    {
        List<String> fieldNames = new ArrayList<>();

        for(Field field : fields)
        {
            fieldNames.add(field.getName());
        }

        return fieldNames;
    }

    public List<String> getFieldPaths()
    {
        List<String> fieldPaths = new ArrayList<>();
        if (fields.isEmpty()) return fieldPaths;

        for(Field field : fields)
        {
            fieldPaths.add(field.getPath());
        }

        return fieldPaths;
    }

    public static Builder newBuilder() {

        return new Builder();
    }


    /******************************************
     * Builder.  A functional interface with a single method (withName) that starts the build.
     */

    public static class Builder
    {

        @Accessors(chain = true) @NonNull @Setter() List<Field> fields;
        @Accessors(chain = true) @NonNull @Setter() List<String> keyFields;

        public Schema build(){

            Schema obj = new Schema();

            obj.setFields(fields);
            obj.setKeyFields(keyFields);

            return obj;
        }
    }

}
